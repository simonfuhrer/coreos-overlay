From 82b15b0baaae84d8966cddf2dfbd5b38936368e3 Mon Sep 17 00:00:00 2001
Message-Id: <82b15b0baaae84d8966cddf2dfbd5b38936368e3.1564739462.git.dongsu@kinvolk.io>
From: =?UTF-8?q?Mauricio=20V=C3=A1squez?= <mauricio@kinvolk.io>
Date: Mon, 22 Jul 2019 14:20:11 -0500
Subject: [PATCH] cgroups/systemd: add cgroup-v2 path to the list when using
 hybrid mode
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Currently, the parent process of the container is moved to the right
cgroup-v2 tree when systemd is using a hybrid model (last line with 0::):

$ runc --systemd-cgroup run myid
/ # cat /proc/self/cgroup
12:cpuset:/system.slice/runc-myid.scope
11:blkio:/system.slice/runc-myid.scope
10:devices:/system.slice/runc-myid.scope
9:hugetlb:/system.slice/runc-myid.scope
8:memory:/system.slice/runc-myid.scope
7:rdma:/
6:perf_event:/system.slice/runc-myid.scope
5:net_cls,net_prio:/system.slice/runc-myid.scope
4:freezer:/system.slice/runc-myid.scope
3:pids:/system.slice/runc-myid.scope
2:cpu,cpuacct:/system.slice/runc-myid.scope
1:name=systemd:/system.slice/runc-myid.scope
0::/system.slice/runc-myid.scope

However, if a second process is executed in the same container, it is
not moved to the right cgroup-v2 tree:

$ runc exec myid /bin/sh -c 'cat /proc/self/cgroup'
12:cpuset:/system.slice/runc-myid.scope
11:blkio:/system.slice/runc-myid.scope
10:devices:/system.slice/runc-myid.scope
9:hugetlb:/system.slice/runc-myid.scope
8:memory:/system.slice/runc-myid.scope
7:rdma:/
6:perf_event:/system.slice/runc-myid.scope
5:net_cls,net_prio:/system.slice/runc-myid.scope
4:freezer:/system.slice/runc-myid.scope
3:pids:/system.slice/runc-myid.scope
2:cpu,cpuacct:/system.slice/runc-myid.scope
1:name=systemd:/system.slice/runc-myid.scope
0::/user.slice/user-1000.slice/session-8.scope

Having the processes of the container in its own cgroup-v2 is useful
for any BPF programs that rely on bpf_get_current_cgroup_id(), like
https://github.com/kinvolk/inspektor-gadget/ for instance.

This commit makes that processes executed with exec are placed into the
right cgroup-v2 tree.  The implementation checks if systemd is using a
hybrid mode (by checking if cgroups-v2 is mounted in
/sys/fs/cgroup/unified), if yes, the path of the cgroup-v2 slice for
this container is saved into the cgroup path list.

Signed-off-by: Mauricio VÃ¡squez <mauricio@kinvolk.io>
---
 libcontainer/cgroups/systemd/apply_systemd.go | 43 +++++++++++++++++--
 1 file changed, 40 insertions(+), 3 deletions(-)

diff --git a/libcontainer/cgroups/systemd/apply_systemd.go b/libcontainer/cgroups/systemd/apply_systemd.go
index 3bf723bf..75b0db63 100644
--- a/libcontainer/cgroups/systemd/apply_systemd.go
+++ b/libcontainer/cgroups/systemd/apply_systemd.go
@@ -20,6 +20,7 @@ import (
 	"github.com/opencontainers/runc/libcontainer/cgroups/fs"
 	"github.com/opencontainers/runc/libcontainer/configs"
 	"github.com/sirupsen/logrus"
+	"golang.org/x/sys/unix"
 )
 
 type Manager struct {
@@ -69,6 +70,7 @@ var subsystems = subsystemSet{
 const (
 	testScopeWait = 4
 	testSliceWait = 4
+	cgroupUnified = "/sys/fs/cgroup/unified"
 )
 
 var (
@@ -321,6 +323,19 @@ func (m *Manager) Apply(pid int) error {
 		}
 		paths[s.Name()] = subsystemPath
 	}
+
+	// If systemd is using cgroups-v2 add the slice path of this container to
+	// the paths so following process executed with exec join that cgroup-v2
+	// as well
+	if isCgroupsv2Available() {
+		// "" means cgroup-v2 path
+		cgroupsv2Path, err := getSubsystemPath(m.Cgroups, "")
+		if err != nil && cgroups.IsNotFound(err) {
+			return err
+		}
+		paths["cgroups-v2"] = cgroupsv2Path
+	}
+
 	m.Paths = paths
 	return nil
 }
@@ -430,10 +445,32 @@ func ExpandSlice(slice string) (string, error) {
 	return path, nil
 }
 
+// Check if cgroups-v2 is mounted on /sys/fs/cgroup/unified/ as stated in
+// https://systemd.io/CGROUP_DELEGATION.html#three-different-tree-setups-
+// Only the hybrid mode is taken into consideration as unified mode is not
+// supported in runc yet
+func isCgroupsv2Available() bool {
+	var statfs unix.Statfs_t
+
+	if err := unix.Statfs(cgroupUnified, &statfs); err != nil {
+		return false
+	}
+
+	return (statfs.Type == unix.CGROUP2_SUPER_MAGIC)
+}
+
 func getSubsystemPath(c *configs.Cgroup, subsystem string) (string, error) {
-	mountpoint, err := cgroups.FindCgroupMountpoint(c.Path, subsystem)
-	if err != nil {
-		return "", err
+	var mountpoint string
+	// if subsystem is empty it means that we are looking for the
+	// cgroups-v2 path
+	if len(subsystem) == 0 {
+		mountpoint = cgroupUnified
+	} else {
+		var err error
+		mountpoint, err = cgroups.FindCgroupMountpoint(c.Path, subsystem)
+		if err != nil {
+			return "", err
+		}
 	}
 
 	initPath, err := cgroups.GetInitCgroup(subsystem)
-- 
2.21.0

